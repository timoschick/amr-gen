package gen;

import dag.AlignedWord;
import dag.AlignmentType;
import dag.Amr;
import dag.Vertex;
import edu.berkeley.nlp.lm.ArrayEncodedNgramLanguageModel;
import edu.berkeley.nlp.lm.collections.BoundedList;
import edu.stanford.nlp.ling.Datum;
import misc.StaticHelper;
import misc.WordLists;
import ml.DenomMaxentModel;
import ml.Prediction;

import java.util.*;
import java.util.stream.Collectors;

/**
 * This class performs post-processing as described in the thesis.
 */
public class PostProcessor {

    private final ArrayEncodedNgramLanguageModel<String> lm;
    private final DenomMaxentModel denomMaxentModel;

    // hyperparameters used by the post processor
    public double articleLmWeight;
    public double defaultArticlePredScore;
    public double defaultArticleSmoothing;
    public double articleAdditionHandicap;
    public double linkRemovalHandicap;

    /**
     * Creates a new PostProcessor.
     * @param lm the language model to be used for post processing
     * @param denomMaxentModel the maximum entropy model to be used for denominator probabilities
     */
    public PostProcessor(ArrayEncodedNgramLanguageModel<String> lm, DenomMaxentModel denomMaxentModel) {
        this.lm = lm;
        this.denomMaxentModel = denomMaxentModel;
    }

    /**
     * Post-processes a list of AMR graphs.
     * @param amrs the AMR graphs to post-process
     * @return the sentences generated from the AMR graphs
     */
    public List<String> postProcess(List<Amr> amrs) {
        List<String> ret = new ArrayList<>();
        for(Amr amr: amrs) {
            PartialTransitionFunction backup = new PartialTransitionFunction();
            backup.addCopy(amr.partialTransitionFunction);
            postProcess(amr);

            String generatedSentence = amr.yield(amr.partialTransitionFunction);

            // remove duplicate words from the realization
            generatedSentence = StaticHelper.removeDuplicateWords(generatedSentence);

            // add spaces before "'s" to reflect tokenization and convert the generated sentence to lower case
            generatedSentence = generatedSentence.replace("'s", " 's").toLowerCase();

            // for sentences that consist of only two words, we remove articles
            if(generatedSentence.matches("the [A-z]+")) generatedSentence = generatedSentence.replace("the ", "");

            ret.add(generatedSentence);
            amr.partialTransitionFunction = backup;

        }
        return ret;
    }

    /**
     * Post-processes a single AMR graph.
     * @param amr the AMR graph to post-process
     */
    public void postProcess(Amr amr) {

        if(amr.partialTransitionFunction == null) throw new AssertionError("Postprocessing an AMR graph is not possible without a partial transition function.");
        List<AlignedWord> result = amr.yieldList(amr.partialTransitionFunction);
        postProcess(amr, result);

    }

    /**
     * Post-processes a single AMR graph.
     * @param amr the AMR graph to post-process
     * @param result the sentence generated by the transition system, represented by a list of {@link AlignedWord}s.
     */
    private void postProcess(Amr amr, List<AlignedWord> result) {

        for(Vertex v: amr.dag) {
            if(amr.partialTransitionFunction.pos.containsKey(v) && v.isPropbankEntry()) {
                v.setPos(amr.partialTransitionFunction.pos.get(v));
            }
        }

        for(AlignedWord aw: result) {

            // check whether words corresponding to links should be removed according to the language model
            if(aw.type == AlignmentType.TRANSLATION && aw.alignment.isLink() && !aw.word.isEmpty()) {

                double scoreWithArticle = scoreNonemptyContext(aw, result, 2, false);
                double scoreWithoutArticle = scoreNonemptyContext(aw, "", result, 2, false);

                if(scoreWithoutArticle > scoreWithArticle * linkRemovalHandicap) {
                    aw.word = "";
                    amr.partialTransitionFunction.realization.put(aw.alignment, aw.word);
                }
            }


        }

        for(AlignedWord aw: result) {

            // add or remove articles according to the language model
            String pos = amr.partialTransitionFunction.pos.get(aw.alignment);
            if (aw.type == AlignmentType.ARTICLE && pos != null && pos.equals("NN")) {

                if (aw.alignment.isPropbankEntry()) aw.alignment.setPos("NN");
                List<Prediction> articlePredictions = new ArrayList<>();

                String numerus = amr.partialTransitionFunction.number.getOrDefault(aw.alignment, GoldSyntacticAnnotations.SINGULAR);
                String real = amr.partialTransitionFunction.realization.get(aw.alignment);

                List<Datum<String, String>> articleDatumList = denomMaxentModel.toDatumList(amr, aw.alignment, true, numerus, real);
                if (!articleDatumList.isEmpty()) {
                    Datum<String, String> articleDatum = articleDatumList.get(0);
                    List<Prediction> preds = denomMaxentModel.getNBestSorted(articleDatum);
                    for (Prediction p : preds) {
                        Prediction articlePred = new Prediction(p.getValue().replace("-", ""), p.getScore());
                        articlePredictions.add(articlePred);
                    }
                }


                if (!canHaveArticle(amr, result, aw)) {
                    aw.word = "";
                    amr.partialTransitionFunction.denominator.put(aw.alignment, aw.word);
                    continue;
                }

                double thePredScore = defaultArticlePredScore;
                double aPredScore = defaultArticlePredScore;
                double noArticlePredScore = defaultArticlePredScore;

                for (Prediction p : articlePredictions) {
                    if (p.getValue().equals("the")) {
                        thePredScore = Math.max(thePredScore, p.getScore());
                    } else if (p.getValue().equals("a")) {
                        aPredScore = Math.max(aPredScore, p.getScore());
                    } else if (p.getValue().isEmpty()) {
                        noArticlePredScore = Math.max(noArticlePredScore, p.getScore());
                    }
                }

                thePredScore += defaultArticleSmoothing;
                aPredScore += defaultArticleSmoothing;
                noArticlePredScore += defaultArticleSmoothing;

                thePredScore = Math.log(thePredScore);
                aPredScore = Math.log(aPredScore);
                noArticlePredScore = Math.log(noArticlePredScore);

                double scoreWithThe = articleLmWeight * scoreNonemptyContext(aw, "the", result, 2, false) + (1 - articleLmWeight) * thePredScore;
                double scoreWithA = articleLmWeight * scoreNonemptyContext(aw, "a", result, 2, false) + (1 - articleLmWeight) * aPredScore;
                double scoreWithAn = articleLmWeight * scoreNonemptyContext(aw, "an", result, 2, false) + (1 - articleLmWeight) * aPredScore;
                double scoreWithoutArticle = articleLmWeight * scoreNonemptyContext(aw, result, 2, false) + (1 - articleLmWeight) * noArticlePredScore;

                String bestArticle = "the";
                double bestArticleScore = scoreWithThe;
                if (scoreWithA > bestArticleScore) {
                    bestArticle = "a";
                    bestArticleScore = scoreWithA;
                }
                if (scoreWithAn > bestArticleScore) {
                    bestArticle = "an";
                    bestArticleScore = scoreWithAn;
                }
                if (bestArticleScore > scoreWithoutArticle * articleAdditionHandicap && !SecondStageProcessor.articleDisallowed(aw.alignment)) {
                    aw.word = bestArticle;
                    amr.partialTransitionFunction.denominator.put(aw.alignment, aw.word);
                }
            }
        }
    }

    /**
     * Computes the language model score of a local context of nonempty words around a given word.
     * @param word the word for which the context should be scored
     * @param sentence the sentence in which the word is embedded
     * @param contextSize the context size. Let {@code i} denote the position of {@code word}; then the words
     *                    at positions {@code i - contextSize, i - contextSize + 1, ..., i, i + 1, ..., i + contextSize} are considered.
     * @param withPunctuation whether punctuation should be included
     * @return the language model score of the context
     */
    private double scoreNonemptyContext(AlignedWord word, List<AlignedWord> sentence, int contextSize, boolean withPunctuation) {
        return scoreNonemptyContext(word, word.word, sentence, contextSize, withPunctuation);
    }

    /**
     * Computes the language model score of a local context of nonempty words around a given word if said word is replaced by another word.
     * @param word the word for which the context should be scored
     * @param insertionForAw the word by which {@code word} shall be replaced
     * @param sentence the sentence in which the word is embedded
     * @param contextSize the context size. Let {@code i} denote the position of {@code word}; then the words
     *                    at positions {@code i - contextSize, i - contextSize + 1, ..., i, i + 1, ..., i + contextSize} are considered.
     * @param withPunctuation whether punctuation should be included
     * @return the language model score of the context
     */
    private double scoreNonemptyContext(AlignedWord word, String insertionForAw, List<AlignedWord> sentence, int contextSize, boolean withPunctuation) {
        List<String> nonemptyContext = getNonemptyContext(word, insertionForAw, sentence, contextSize, withPunctuation);
        return SecondStageProcessor.scoreSentence(nonemptyContext, lm, false, false);
    }

    /**
     * Returns a local context of nonempty words around a given word where said word is replaced by another word. The local context is represented
     * by a list of strings.
     * @param word the word for which the context should be computed
     * @param insertionForAw the word by which {@code word} shall be replaced
     * @param sentence the sentence in which the word is embedded
     * @param contextSize the context size. Let {@code i} denote the position of {@code word}; then the words
     *                    at positions {@code i - contextSize, i - contextSize + 1, ..., i, i + 1, ..., i + contextSize} are considered.
     * @param withPunctuation whether punctuation should be included
     * @return the context
     */
    private List<String> getNonemptyContext(AlignedWord word, String insertionForAw, List<AlignedWord> sentence, int contextSize, boolean withPunctuation) {

        List<AlignedWord> ret = sentence.stream().filter(e -> (!e.word.isEmpty() && (e.type != AlignmentType.PUNCTUATION || withPunctuation)) || (e == word)).collect(Collectors.toList());
        int wordIndex = ret.indexOf(word);

        List<String> retString = ret.stream().map(e -> e.word).collect(Collectors.toList());

        BoundedList<String> retBounded = new BoundedList<>(retString, lm.getWordIndexer().getStartSymbol(), lm.getWordIndexer().getEndSymbol());

        List<String> leftSide = retBounded.subList(wordIndex - contextSize, wordIndex);
        List<String> rightSide = retBounded.subList(wordIndex + 1, wordIndex + contextSize + 1);

        String lsString = String.join(" ", leftSide);
        String rsString = String.join(" ", rightSide);
        List<String> ls = Arrays.asList(lsString.split(" "));
        List<String> rs = Arrays.asList(rsString.split(" "));

        List<String> finalRet = new ArrayList<>();
        finalRet.addAll(ls.subList(ls.size() - contextSize, ls.size()));
        if(!insertionForAw.isEmpty()) finalRet.add(insertionForAw);
        finalRet.addAll(rs.subList(0, contextSize));

        return finalRet;
    }

    /**
     * This function checks whether a word of a sentence generated from some AMR graph is allowed to have an article.
     * A word is not allowed to have an article, if one of the following holds:
     * <ul>
     *     <li>the word directly to its left or right already is an article;</li>
     *     <li>the corresponding vertex is an instance of the concept "person" and has a name;</li>
     *     <li>the word is empty.</li>
     * </ul>
     * @param amr the AMR graph from which the sentence was created
     * @param aws the sentence, represented as a list of {@code AlignedWord}s
     * @param aw the word to check
     * @return true iff the word is allowed to have an article
     */
    private boolean canHaveArticle(Amr amr, List<AlignedWord> aws, AlignedWord aw) {

        List<String> context = getNonemptyContext(aw, "", aws, 1, false);

        if(!Collections.disjoint(context, WordLists.articles)) return false;

        if(aw.alignment.getInstance().equals("person") && !aw.alignment.name.isEmpty()) return false;
        if(amr.partialTransitionFunction.realization.get(aw.alignment).isEmpty()) return false;

        return true;

    }

}
